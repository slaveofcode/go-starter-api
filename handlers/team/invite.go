package team

import (
	"encoding/json"
	"os"

	"github.com/jinzhu/gorm"
	"github.com/matcornic/hermes"
	"github.com/sirupsen/logrus"
	"github.com/slaveofcode/go-starter-api/lib/httpresponse"
	"github.com/slaveofcode/go-starter-api/lib/mail"
	"github.com/slaveofcode/go-starter-api/lib/random"
	"github.com/slaveofcode/go-starter-api/lib/session"
	"github.com/slaveofcode/go-starter-api/repository/pg/models"
	"github.com/valyala/fasthttp"
	"gopkg.in/go-playground/validator.v9"
)

const maxTeamMember = 5

type inviteTeamBodyParam struct {
	TeamID      uint   `json:"teamId" validate:"required"`
	Email       string `json:"email" validate:"required,email"`
	RoleID      uint   `json:"roleId" validate:"required"`
	ForceInvite bool   `json:"forceInviteAgain"`
}

// InviteMember send invitation to join to the team
func (t Team) InviteMember(sessionData *session.Data) func(*fasthttp.RequestCtx) {
	return func(ctx *fasthttp.RequestCtx) {

		var param inviteTeamBodyParam
		err := json.Unmarshal(ctx.PostBody(), &param)
		if err != nil {
			httpresponse.JSONErr(ctx, "Wrong post data: "+err.Error(), fasthttp.StatusBadRequest)
			return
		}

		v := validator.New()
		err = v.Struct(param)
		if err != nil {
			httpresponse.JSONErr(ctx, "Invalid post data: "+err.Error(), fasthttp.StatusBadRequest)
			return
		}

		db := t.appCtx.DB

		var team models.Team
		if db.Where(&models.Team{
			ID: param.TeamID,
		}).First(&team).RecordNotFound() {
			httpresponse.JSONErr(ctx, "Invalid request", fasthttp.StatusBadRequest)
			return
		}

		var teamMember models.TeamMember
		if db.Where(&models.TeamMember{
			TeamID: team.ID,
			UserID: sessionData.UserID,
		}).First(&teamMember).RecordNotFound() {
			httpresponse.JSONErr(ctx, "Invalid request", fasthttp.StatusBadRequest)
			return
		}

		valid, _ := isValidRoleToInvite(db, teamMember.RoleID, param.RoleID)
		if !valid {
			httpresponse.JSONErr(ctx, "Invalid request", fasthttp.StatusBadRequest)
			return
		}

		var invitation models.TeamMemberInvitation
		if !db.Where(&models.TeamMemberInvitation{
			TeamID: param.TeamID,
			Email:  param.Email,
			RoleID: param.RoleID,
		}).First(&invitation).RecordNotFound() && !param.ForceInvite {
			httpresponse.JSONErr(ctx, "Already invited", fasthttp.StatusBadRequest)
			return
		}

		if invitation.ID == 0 || invitation.ID != 0 && param.ForceInvite {
			invitationKey := random.GetStr(32)
			if err := db.Create(&models.TeamMemberInvitation{
				TeamID:        param.TeamID,
				Email:         param.Email,
				InvitationKey: invitationKey,
				RoleID:        param.RoleID,
			}).Error; err != nil {
				httpresponse.JSONErr(ctx, "Unable to create invitation", fasthttp.StatusInternalServerError)
				return
			}

			sendEmailInvitation(team.Name, param.Email, invitationKey)

			httpresponse.JSONOk(ctx, fasthttp.StatusOK)
			return
		}

		httpresponse.JSONErr(ctx, "Already invited", fasthttp.StatusBadRequest)
		return
	}
}

func generateMailInviteTpl(teamName, token string) (string, string) {
	webBaseURL := os.Getenv("WEB_BASE_URL")
	h := hermes.Hermes{
		// Optional Theme
		// Theme: new(Default)
		Product: hermes.Product{
			// Appears in header & footer of e-mails
			Name: "Ayok.be",
			Link: webBaseURL,
			// Optional product logo
			Logo: os.Getenv("MAIL_LOGO_IMG_URL"),
		},
	}

	email := hermes.Email{
		Body: hermes.Body{
			Name: teamName,
			Intros: []string{
				"Invitation to " + teamName + " Team!",
			},
			Actions: []hermes.Action{
				{
					Instructions: "You're invited to be a member of " + teamName + " team!",
					Button: hermes.Button{
						Color: "#22BC66", // Optional action button color
						Text:  "Join the Team",
						Link:  webBaseURL + "/team/join?token=" + token,
					},
				},
			},
			Outros: []string{
				"This email is generated by system, please not replying to this email",
			},
		},
	}

	// Generate an HTML email with the provided contents (for modern clients)
	emailBody, err := h.GenerateHTML(email)
	if err != nil {
		panic(err) // Tip: Handle error with something else than a panic ;)
	}

	// Generate the plaintext version of the e-mail (for clients that do not support xHTML)
	emailText, err := h.GeneratePlainText(email)
	if err != nil {
		panic(err) // Tip: Handle error with something else than a panic ;)
	}

	return emailBody, emailText
}

func sendEmailInvitation(teamName, email, token string) error {
	msgHTML, msgText := generateMailInviteTpl(teamName, token)
	out, err := mail.Send(&mail.Template{
		From: os.Getenv("SES_FROM_EMAIL"),
		Recipients: []*string{
			&email,
		},
		Subject: "Team Invitation!",
		HTML:    msgHTML,
		Text:    msgText,
	})

	logrus.Info(out)
	return err
}

func isValidRoleToInvite(db *gorm.DB, userRoleID, memberRoleID uint) (bool, error) {
	var userRole models.Role
	err := db.Where(&models.Role{
		ID: userRoleID,
	}).First(&userRole).Error

	var memberRole models.Role
	err = db.Where(&models.Role{
		ID: memberRoleID,
	}).First(&memberRole).Error

	if err != nil {
		return false, err
	}

	if userRole.Name == Owner || userRole.Name == Manager {
		return true, nil
	}

	if memberRole.Name == Manager || memberRole.Name == Staff {
		return true, nil
	}

	return false, nil
}
